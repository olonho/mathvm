#pragma once

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <mathvm.h>
#include <ast.h>
using namespace mathvm;


/*
* new stack generated by enter block
*/

class SingleVar
{
public:
	SingleVar(VarType _type, const string& _name, SingleVar* _inPrevStack = 0):
		type_(_type), name_(_name), inPrevStack_(_inPrevStack), isUsed_(false)
	{}


	SingleVar* makeLikePointer()
	{
		return new SingleVar(type_, name_, this);
	}

	void markAsUsed()
	{
		isUsed_ = true;
		if (inPrevStack_)
			inPrevStack_->markAsUsed();
	}

	bool operator==(const SingleVar& sv)
	{
		return sv.type_ == type_ && sv.name_.compare(name_) == 0;
	}

	bool isEqual(VarType _type, const string& _name)
	{
		return _type == type_ && _name.compare(name_) == 0;
	}

	bool isUsed() const
	{
		return isUsed_;
	}

	void setIsUsed(bool _isUsed)
	{
		isUsed_ = _isUsed;
	}

	pair<VarType, string> extractVar()
	{
		return make_pair(type_, name_);
	}

private:
	VarType type_;
	string  name_;

	// points to var in previous stack, if null - by value, otherwise by pointer
	SingleVar* inPrevStack_;
	// by default all variable is unused, mark - recursive mark all previous vars
	bool isUsed_;
};

class CallStack
{
public:
	CallStack():prev_(0), fstSignature_(0), fstLocal_(0){}
	~CallStack()
	{
		for (size_t i = 0; i < vars_.size();++i)
			delete vars_[i];
	}

	CallStack* enterBlock(Scope::VarIterator it, const Signature& signature)
	{
		CallStack* s = new CallStack();
		s->prev_ = this;

		for(size_t i = 0; i < vars_.size(); ++i)
			s->vars_.push_back(vars_[i]->makeLikePointer());

		s->fstSignature_ = s->vars_.size();

		for (size_t i = 1; i < signature.size(); ++i)
			s->vars_.push_back(new SingleVar(signature[i].first, signature[i].second));

		s->fstLocal_ = s->vars_.size();

		while(it.hasNext())
		{
			AstVar* v = it.next();
			s->vars_.push_back(new SingleVar(v->type(), v->name()));
		}
		return s;
	}

	SingleVar* lookup(VarType type, const string& name)
	{
		for (int i = vars_.size() - 1; i >= 0; --i)
			if (vars_[i]->isEqual(type, name))
				return vars_[i];
		if (prev_)
			return prev_->lookup(type, name);
		return 0;
	}

	void saveAndClearMarks()
	{
		tmpMarks_.resize(vars_.size());
		for (size_t i = 0; i < vars_.size(); ++i)
		{
			vars_[i]->setIsUsed(false);
			tmpMarks_[i] = vars_[i]->isUsed();
		}
	}

	vector<pair<VarType, string> > extractUsed() const
	{
		vector<pair<VarType, string> > vars;
		for (size_t i = 0; i < vars_.size(); ++i)
			if (vars_[i]->isUsed())
				vars.push_back(vars_[i]->extractVar());
		return vars;
	}

	vector<SingleVar*> extractUsedPointers() const
	{
		vector<SingleVar*> vars;
		for (size_t i = 0; i < vars_.size(); ++i)
			if (vars_[i]->isUsed())
				vars.push_back(vars_[i]);
		return vars;
	}

	void restoreMarks()
	{
		for (size_t i = 0; i < vars_.size(); ++i)
			vars_[i]->setIsUsed(tmpMarks_[i]);
	}

private:
	CallStack* prev_;
	vector<SingleVar*> vars_;
	vector<bool> tmpMarks_;

	int fstSignature_;
	int fstLocal_;
};
